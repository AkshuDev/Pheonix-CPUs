$date
	Mon Dec 22 21:34:49 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_core $end
$var reg 1 ! clk $end
$var reg 64 " inst [63:0] $end
$var reg 1 # rst $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 $ core_inuse $end
$var wire 1 % core_reset $end
$var wire 1 & enable $end
$var wire 1 ' grant_t0_alu $end
$var wire 1 ( grant_t1_alu $end
$var wire 1 ) ring_ready $end
$var wire 1 # rst $end
$var wire 1 * t1_req_l1i $end
$var wire 1 + t1_req_l1d $end
$var wire 1 , t1_req_alu $end
$var wire 1 - t1_locked $end
$var wire 64 . t1_l1i_addr [63:0] $end
$var wire 64 / t1_l1d_addr [63:0] $end
$var wire 1 0 t1_in_use $end
$var wire 1 1 t1_alu_valid $end
$var wire 8 2 t1_alu_op [7:0] $end
$var wire 64 3 t1_alu_b [63:0] $end
$var wire 64 4 t1_alu_a [63:0] $end
$var wire 1 5 t0_req_l1i $end
$var wire 1 6 t0_req_l1d $end
$var wire 1 7 t0_req_alu $end
$var wire 1 8 t0_locked $end
$var wire 64 9 t0_l1i_addr [63:0] $end
$var wire 64 : t0_l1d_addr [63:0] $end
$var wire 1 ; t0_in_use $end
$var wire 1 < t0_alu_valid $end
$var wire 8 = t0_alu_op [7:0] $end
$var wire 64 > t0_alu_b [63:0] $end
$var wire 64 ? t0_alu_a [63:0] $end
$var wire 1 @ l1i_wr_done $end
$var wire 1 A l1i_rd_done $end
$var wire 64 B l1i_data [63:0] $end
$var wire 1 C l1d_wr_done $end
$var wire 1 D l1d_rd_done $end
$var wire 64 E l1d_data [63:0] $end
$var wire 1 F alu_zero $end
$var wire 64 G alu_res [63:0] $end
$var wire 1 H alu_overflow $end
$var wire 1 I alu_lt $end
$var wire 1 J alu_gt $end
$var wire 1 K alu_eq $end
$var wire 1 L alu_done $end
$var wire 1 M alu_carry $end
$var parameter 32 N ADDR_W $end
$var parameter 32 O DATA_W $end
$var parameter 32 P L1_SIZE $end
$var parameter 4 Q ST_DONE $end
$var parameter 4 R ST_FILL $end
$var parameter 4 S ST_GRANT_L1D $end
$var parameter 4 T ST_GRANT_L1I $end
$var parameter 4 U ST_IDLE $end
$var parameter 4 V ST_REQ_L2 $end
$var reg 64 W alu_a [63:0] $end
$var reg 64 X alu_b [63:0] $end
$var reg 1 Y alu_busy $end
$var reg 1 Z alu_en $end
$var reg 8 [ alu_op [7:0] $end
$var reg 2 \ alu_owner [1:0] $end
$var reg 1 ] alu_valid $end
$var reg 4 ^ core_state [3:0] $end
$var reg 32 _ fill_index [31:0] $end
$var reg 1 ` grant_thread $end
$var reg 64 a l1d_addr [63:0] $end
$var reg 1 b l1d_rd_en $end
$var reg 64 c l1d_wr_data [63:0] $end
$var reg 1 d l1d_wr_en $end
$var reg 64 e l1i_addr [63:0] $end
$var reg 64 f l1i_baddr [63:0] $end
$var reg 1 g l1i_rd_en $end
$var reg 64 h l1i_wr_data [63:0] $end
$var reg 1 i l1i_wr_en $end
$var reg 1 j last_grant $end
$var reg 64 k refill_addr [63:0] $end
$var reg 64 l ring_addr [63:0] $end
$var reg 1 m ring_req $end
$var reg 1 n t0_alu_done $end
$var reg 64 o t0_alu_res [63:0] $end
$var reg 1 p t0_enable $end
$var reg 64 q t0_l1d_data [63:0] $end
$var reg 1 r t0_l1d_ready $end
$var reg 64 s t0_l1i_data [63:0] $end
$var reg 1 t t0_l1i_ready $end
$var reg 1 u t0_reset $end
$var reg 1 v t1_alu_done $end
$var reg 64 w t1_alu_res [63:0] $end
$var reg 1 x t1_enable $end
$var reg 64 y t1_l1d_data [63:0] $end
$var reg 1 z t1_l1d_ready $end
$var reg 64 { t1_l1i_data [63:0] $end
$var reg 1 | t1_l1i_ready $end
$var reg 1 } t1_reset $end
$scope module alu_u $end
$var wire 64 ~ a [63:0] $end
$var wire 64 !" b [63:0] $end
$var wire 1 ! clk $end
$var wire 8 "" op [7:0] $end
$var wire 1 # rst $end
$var wire 1 ] valid $end
$var wire 1 F zero $end
$var parameter 32 #" DATA_W $end
$var parameter 32 $" OP_W $end
$var reg 1 M carry $end
$var reg 1 L done $end
$var reg 1 K eq $end
$var reg 1 J gt $end
$var reg 1 I lt $end
$var reg 1 H overflow $end
$var reg 64 %" res [63:0] $end
$var reg 1 &" valid_d $end
$upscope $end
$scope module l1d $end
$var wire 64 '" addr [63:0] $end
$var wire 1 ! clk $end
$var wire 1 b rd_en $end
$var wire 1 # rst $end
$var wire 64 (" wr_data [63:0] $end
$var wire 1 d wr_en $end
$var parameter 32 )" BYTES $end
$var parameter 32 *" DATA_W $end
$var parameter 32 +" DEPTH $end
$var reg 64 ," rd_data [63:0] $end
$var reg 1 D rd_done $end
$var reg 1 C wr_done $end
$var integer 32 -" i [31:0] $end
$upscope $end
$scope module l1i $end
$var wire 64 ." addr [63:0] $end
$var wire 1 ! clk $end
$var wire 1 g rd_en $end
$var wire 1 # rst $end
$var wire 64 /" wr_data [63:0] $end
$var wire 1 i wr_en $end
$var parameter 32 0" BYTES $end
$var parameter 32 1" DATA_W $end
$var parameter 32 2" DEPTH $end
$var reg 64 3" rd_data [63:0] $end
$var reg 1 A rd_done $end
$var reg 1 @ wr_done $end
$var integer 32 4" i [31:0] $end
$upscope $end
$scope module t0 $end
$var wire 1 5" alu_carry $end
$var wire 1 n alu_done $end
$var wire 1 6" alu_eq $end
$var wire 1 7" alu_gt $end
$var wire 1 8" alu_lt $end
$var wire 1 9" alu_overflow $end
$var wire 64 :" alu_res [63:0] $end
$var wire 1 ;" alu_zero $end
$var wire 1 ! clk $end
$var wire 1 p enable $end
$var wire 1 <" inst_valid $end
$var wire 1 =" is_wr_pl_en $end
$var wire 64 >" l1d_data [63:0] $end
$var wire 1 r l1d_ready $end
$var wire 64 ?" l1i_data [63:0] $end
$var wire 1 t l1i_ready $end
$var wire 1 @" regs_valid $end
$var wire 1 # rst $end
$var wire 1 u thread_reset $end
$var wire 1 A" verify_ok $end
$var wire 6 B" rsrc [5:0] $end
$var wire 64 C" rf_rd2_data [63:0] $end
$var wire 64 D" rf_rd1_data [63:0] $end
$var wire 6 E" rdest [5:0] $end
$var wire 12 F" opcode [11:0] $end
$var wire 4 G" mode [3:0] $end
$var wire 64 H" is_rd2_data [63:0] $end
$var wire 64 I" is_rd1_data [63:0] $end
$var wire 4 J" is_pl [3:0] $end
$var wire 1 K" imm_en $end
$var wire 4 L" flags [3:0] $end
$var wire 1 M" decoded_valid $end
$var parameter 32 N" DATA_W $end
$var parameter 32 O" INST_W $end
$var parameter 3 P" ST_DECODE $end
$var parameter 3 Q" ST_EXECUTE $end
$var parameter 3 R" ST_EXECUTE_P2 $end
$var parameter 3 S" ST_EXECUTE_P3 $end
$var parameter 3 T" ST_FETCH $end
$var parameter 3 U" ST_IDLE $end
$var parameter 3 V" ST_LOCKED $end
$var parameter 3 W" ST_VERIFY $end
$var reg 64 X" alu_a [63:0] $end
$var reg 64 Y" alu_b [63:0] $end
$var reg 1 7 alu_en $end
$var reg 8 Z" alu_op [7:0] $end
$var reg 1 < alu_valid $end
$var reg 64 [" imm_in [63:0] $end
$var reg 1 \" imm_in_en $end
$var reg 1 ; in_use $end
$var reg 32 ]" inst [31:0] $end
$var reg 1 ^" invalid_inst $end
$var reg 6 _" is_rd1_addr [5:0] $end
$var reg 6 `" is_rd2_addr [5:0] $end
$var reg 6 a" is_wr_addr [5:0] $end
$var reg 64 b" is_wr_data [63:0] $end
$var reg 1 c" is_wr_en $end
$var reg 4 d" is_wr_pl [3:0] $end
$var reg 64 e" l1d_addr [63:0] $end
$var reg 64 f" l1i_addr [63:0] $end
$var reg 1 8 locked $end
$var reg 3 g" next_state [2:0] $end
$var reg 64 h" pc [63:0] $end
$var reg 1 6 read_l1d $end
$var reg 1 5 read_l1i $end
$var reg 6 i" rf_rd1_addr [5:0] $end
$var reg 6 j" rf_rd2_addr [5:0] $end
$var reg 6 k" rf_wr_addr [5:0] $end
$var reg 64 l" rf_wr_data [63:0] $end
$var reg 1 m" rf_wr_en $end
$var reg 3 n" state [2:0] $end
$var reg 1 o" using_alu $end
$scope module dec $end
$var wire 1 ! clk $end
$var wire 64 p" imm_in [63:0] $end
$var wire 1 \" imm_in_en $end
$var wire 32 q" inst [31:0] $end
$var wire 1 # rst $end
$var parameter 32 r" DATA_W $end
$var parameter 32 s" INST_W $end
$var parameter 32 t" REG_W $end
$var reg 1 M" decoded_valid $end
$var reg 4 u" flags [3:0] $end
$var reg 64 v" imm [63:0] $end
$var reg 1 K" imm_en $end
$var reg 4 w" mode [3:0] $end
$var reg 12 x" opcode [11:0] $end
$var reg 6 y" rdest [5:0] $end
$var reg 6 z" rsrc [5:0] $end
$var reg 1 {" waiting_for_imm $end
$upscope $end
$scope module is $end
$var wire 1 ! clk $end
$var wire 6 |" rd1_addr [5:0] $end
$var wire 6 }" rd2_addr [5:0] $end
$var wire 4 ~" rd_pl_out [3:0] $end
$var wire 1 # rst $end
$var wire 6 !# wr1_addr [5:0] $end
$var wire 64 "# wr1_data [63:0] $end
$var wire 1 c" wr_en $end
$var wire 4 ## wr_pl_data [3:0] $end
$var wire 1 =" wr_pl_en $end
$var wire 64 $# rd2_out [63:0] $end
$var wire 64 %# rd1_out [63:0] $end
$var parameter 32 &# DATA_W $end
$var reg 4 '# pl [3:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 (# i [31:0] $end
$upscope $end
$upscope $end
$scope module rf $end
$var wire 1 ! clk $end
$var wire 6 )# rd1_addr [5:0] $end
$var wire 6 *# rd2_addr [5:0] $end
$var wire 1 # rst $end
$var wire 6 +# wr1_addr [5:0] $end
$var wire 64 ,# wr1_data [63:0] $end
$var wire 1 m" wr_en $end
$var wire 64 -# rd2_out [63:0] $end
$var wire 64 .# rd1_out [63:0] $end
$var parameter 32 /# DATA_W $end
$var parameter 32 0# NUM_REGS $end
$var parameter 32 1# REG_ADDR_W $end
$scope begin $ivl_for_loop0 $end
$var integer 32 2# i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module t1 $end
$var wire 1 3# alu_carry $end
$var wire 1 v alu_done $end
$var wire 1 4# alu_eq $end
$var wire 1 5# alu_gt $end
$var wire 1 6# alu_lt $end
$var wire 1 7# alu_overflow $end
$var wire 64 8# alu_res [63:0] $end
$var wire 1 9# alu_zero $end
$var wire 1 ! clk $end
$var wire 1 x enable $end
$var wire 1 :# inst_valid $end
$var wire 1 ;# is_wr_pl_en $end
$var wire 64 <# l1d_data [63:0] $end
$var wire 1 z l1d_ready $end
$var wire 64 =# l1i_data [63:0] $end
$var wire 1 | l1i_ready $end
$var wire 1 ># regs_valid $end
$var wire 1 # rst $end
$var wire 1 } thread_reset $end
$var wire 1 ?# verify_ok $end
$var wire 6 @# rsrc [5:0] $end
$var wire 64 A# rf_rd2_data [63:0] $end
$var wire 64 B# rf_rd1_data [63:0] $end
$var wire 6 C# rdest [5:0] $end
$var wire 12 D# opcode [11:0] $end
$var wire 4 E# mode [3:0] $end
$var wire 64 F# is_rd2_data [63:0] $end
$var wire 64 G# is_rd1_data [63:0] $end
$var wire 4 H# is_pl [3:0] $end
$var wire 1 I# imm_en $end
$var wire 4 J# flags [3:0] $end
$var wire 1 K# decoded_valid $end
$var parameter 32 L# DATA_W $end
$var parameter 32 M# INST_W $end
$var parameter 3 N# ST_DECODE $end
$var parameter 3 O# ST_EXECUTE $end
$var parameter 3 P# ST_EXECUTE_P2 $end
$var parameter 3 Q# ST_EXECUTE_P3 $end
$var parameter 3 R# ST_FETCH $end
$var parameter 3 S# ST_IDLE $end
$var parameter 3 T# ST_LOCKED $end
$var parameter 3 U# ST_VERIFY $end
$var reg 64 V# alu_a [63:0] $end
$var reg 64 W# alu_b [63:0] $end
$var reg 1 , alu_en $end
$var reg 8 X# alu_op [7:0] $end
$var reg 1 1 alu_valid $end
$var reg 64 Y# imm_in [63:0] $end
$var reg 1 Z# imm_in_en $end
$var reg 1 0 in_use $end
$var reg 32 [# inst [31:0] $end
$var reg 1 \# invalid_inst $end
$var reg 6 ]# is_rd1_addr [5:0] $end
$var reg 6 ^# is_rd2_addr [5:0] $end
$var reg 6 _# is_wr_addr [5:0] $end
$var reg 64 `# is_wr_data [63:0] $end
$var reg 1 a# is_wr_en $end
$var reg 4 b# is_wr_pl [3:0] $end
$var reg 64 c# l1d_addr [63:0] $end
$var reg 64 d# l1i_addr [63:0] $end
$var reg 1 - locked $end
$var reg 3 e# next_state [2:0] $end
$var reg 64 f# pc [63:0] $end
$var reg 1 + read_l1d $end
$var reg 1 * read_l1i $end
$var reg 6 g# rf_rd1_addr [5:0] $end
$var reg 6 h# rf_rd2_addr [5:0] $end
$var reg 6 i# rf_wr_addr [5:0] $end
$var reg 64 j# rf_wr_data [63:0] $end
$var reg 1 k# rf_wr_en $end
$var reg 3 l# state [2:0] $end
$var reg 1 m# using_alu $end
$scope module dec $end
$var wire 1 ! clk $end
$var wire 64 n# imm_in [63:0] $end
$var wire 1 Z# imm_in_en $end
$var wire 32 o# inst [31:0] $end
$var wire 1 # rst $end
$var parameter 32 p# DATA_W $end
$var parameter 32 q# INST_W $end
$var parameter 32 r# REG_W $end
$var reg 1 K# decoded_valid $end
$var reg 4 s# flags [3:0] $end
$var reg 64 t# imm [63:0] $end
$var reg 1 I# imm_en $end
$var reg 4 u# mode [3:0] $end
$var reg 12 v# opcode [11:0] $end
$var reg 6 w# rdest [5:0] $end
$var reg 6 x# rsrc [5:0] $end
$var reg 1 y# waiting_for_imm $end
$upscope $end
$scope module is $end
$var wire 1 ! clk $end
$var wire 6 z# rd1_addr [5:0] $end
$var wire 6 {# rd2_addr [5:0] $end
$var wire 4 |# rd_pl_out [3:0] $end
$var wire 1 # rst $end
$var wire 6 }# wr1_addr [5:0] $end
$var wire 64 ~# wr1_data [63:0] $end
$var wire 1 a# wr_en $end
$var wire 4 !$ wr_pl_data [3:0] $end
$var wire 1 ;# wr_pl_en $end
$var wire 64 "$ rd2_out [63:0] $end
$var wire 64 #$ rd1_out [63:0] $end
$var parameter 32 $$ DATA_W $end
$var reg 4 %$ pl [3:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 &$ i [31:0] $end
$upscope $end
$upscope $end
$scope module rf $end
$var wire 1 ! clk $end
$var wire 6 '$ rd1_addr [5:0] $end
$var wire 6 ($ rd2_addr [5:0] $end
$var wire 1 # rst $end
$var wire 6 )$ wr1_addr [5:0] $end
$var wire 64 *$ wr1_data [63:0] $end
$var wire 1 k# wr_en $end
$var wire 64 +$ rd2_out [63:0] $end
$var wire 64 ,$ rd1_out [63:0] $end
$var parameter 32 -$ DATA_W $end
$var parameter 32 .$ NUM_REGS $end
$var parameter 32 /$ REG_ADDR_W $end
$scope begin $ivl_for_loop0 $end
$var integer 32 0$ i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b110 /$
b100010 .$
b1000000 -$
b1000000 $$
b110 r#
b100000 q#
b1000000 p#
b11 U#
b111 T#
b0 S#
b1 R#
b110 Q#
b101 P#
b100 O#
b10 N#
b100000 M#
b1000000 L#
b110 1#
b100010 0#
b1000000 /#
b1000000 &#
b110 t"
b100000 s"
b1000000 r"
b11 W"
b111 V"
b0 U"
b1 T"
b110 S"
b101 R"
b100 Q"
b10 P"
b100000 O"
b1000000 N"
b10000000000000000 2"
b1000000 1"
b1000 0"
b10000000000000000 +"
b1000000 *"
b1000 )"
b1000 $"
b1000000 #"
b1 V
b0 U
b100 T
b101 S
b10 R
b11 Q
b10000000000000000 P
b1000000 O
b1000000 N
$end
#0
$dumpvars
bx 0$
bx ,$
bx +$
bx *$
bx )$
bx ($
bx '$
bx &$
bx %$
bx #$
bx "$
bx !$
bx ~#
bx }#
bx |#
bx {#
bx z#
xy#
bx x#
bx w#
bx v#
bx u#
bx t#
bx s#
bx o#
bx n#
xm#
bx l#
xk#
bx j#
bx i#
bx h#
bx g#
bx f#
b0 e#
bx d#
bx c#
bx b#
xa#
bx `#
bx _#
bx ^#
bx ]#
x\#
bx [#
xZ#
bx Y#
bx X#
bx W#
bx V#
xK#
bx J#
xI#
bx H#
bx G#
bx F#
bx E#
bx D#
bx C#
bx B#
bx A#
bx @#
x?#
x>#
bx =#
bx <#
z;#
x:#
z9#
bx 8#
z7#
z6#
z5#
z4#
z3#
bx 2#
bx .#
bx -#
bx ,#
bx +#
bx *#
bx )#
bx (#
bx '#
bx %#
bx $#
bx ##
bx "#
bx !#
bx ~"
bx }"
bx |"
x{"
bx z"
bx y"
bx x"
bx w"
bx v"
bx u"
bx q"
bx p"
xo"
bx n"
xm"
bx l"
bx k"
bx j"
bx i"
bx h"
b0 g"
bx f"
bx e"
bx d"
xc"
bx b"
bx a"
bx `"
bx _"
x^"
bx ]"
x\"
bx ["
bx Z"
bx Y"
bx X"
xM"
bx L"
xK"
bx J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
bx B"
xA"
x@"
bx ?"
bx >"
z="
x<"
z;"
bx :"
z9"
z8"
z7"
z6"
z5"
bx 4"
bx 3"
bx /"
bx ."
bx -"
bx ,"
bx ("
bx '"
x&"
bx %"
bx ""
bx !"
bx ~
x}
x|
bx {
xz
bx y
xx
bx w
xv
xu
xt
bx s
xr
bx q
xp
bx o
xn
xm
bx l
bx k
xj
xi
bx h
xg
bx f
bx e
xd
bx c
xb
bx a
x`
bx _
bx ^
x]
bx \
bx [
xZ
xY
bx X
bx W
xM
xL
xK
xJ
xI
xH
bx G
xF
bx E
xD
xC
bx B
xA
x@
bx ?
bx >
bx =
x<
x;
bx :
bx 9
x8
x7
x6
x5
bx 4
bx 3
bx 2
x1
x0
bx /
bx .
x-
x,
x+
x*
z)
x(
x'
z&
z%
z$
1#
b1000101010010001000000001000100000000000100010000010000100001 "
0!
$end
#5000
0'
0(
b0 X
b0 !"
b0 W
b0 ~
b0 [
b0 ""
0Z
1L
0J
0I
0K
0H
0M
b0 B
b0 3"
0@
0A
b0 E
b0 ,"
0C
0D
b0 J"
b0 ~"
b0 '#
0M"
0{"
0^"
b0 h"
b0 :
b0 e"
b0 9
b0 f"
0;
b0 n"
b0 >
b0 Y"
b0 ?
b0 X"
0o"
0<
08
06
05
07
b0 H#
b0 |#
b0 %$
0K#
0y#
0\#
b0 f#
b0 /
b0 c#
b0 .
b0 d#
00
b0 l#
b0 3
b0 W#
b0 4
b0 V#
0m#
01
0-
0+
0*
0,
0`
b0 f
b0 _
0m
b0 ^
b0 \
0u
0}
0Y
0p
0x
0j
b100 &$
b100010 0$
b100 (#
b100010 2#
b10000000000000000 4"
b10000000000000000 -"
1!
#10000
0!
#15000
1L
b100 &$
b100010 0$
b100 (#
b100010 2#
b10000000000000000 -"
b10000000000000000 4"
1!
#20000
0!
#25000
1L
b100 &$
b100010 0$
b100 (#
b100010 2#
b10000000000000000 4"
b10000000000000000 -"
1!
#30000
0!
#35000
